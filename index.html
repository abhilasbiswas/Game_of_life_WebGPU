<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game of Life</title>
</head>
<body>
    <canvas id="canvas" width="512" height="512"></canvas>


    <script>
        const GRID_SIZE = 32;
        const UPDATE_INTERVAL = 200;
        let step = 0;

        async function main(){

            if (!navigator.gpu){
                alert("WebGPU not supported");
            }

            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter){
                alert("Adapter not found!");
            }

            const device = await adapter.requestDevice();

            const canvas = document.getElementById("canvas");
            const context = canvas.getContext("webgpu");
            const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device: device,
                format: canvasFormat,
            });


            


            const vertices = new Float32Array([
                -0.8, -0.8,
                 0.8, -0.8,
                 0.8,  0.8,

                 0.8,  0.8,
                -0.8,  0.8,
                -0.8, -0.8,
            ])

            const vertexBuffer = device.createBuffer({
                label: "Cell vertices",
                size: vertices.byteLength,
                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
                });

            device.queue.writeBuffer(vertexBuffer, 0, vertices);
            const vertexBufferLayout = {
                arrayStride: 8,
                attributes: [{
                    format: "float32x2",
                    offset: 0,
                    shaderLocation: 0,
                }],
            };

            const uniformArray = new Float32Array([GRID_SIZE, GRID_SIZE]);
            const uniformBuffer = device.createBuffer({
                label: "Grid uniforms",
                size: uniformArray.byteLength,
                usage: GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(uniformBuffer, 0, uniformArray);

            
            const cellShaderModule = device.createShaderModule({
                label: "Cell shader",
                code:`
                    struct VertexIn {
                        @location(0) pos: vec2f,
                        @builtin(instance_index) instance: u32,
                    }
                    struct VertexOut {
                        @builtin(position) pos: vec4f,
                        @location(0) cell: vec2f,
                    }


                    @group(0) @binding(0) var<uniform> grid: vec2f;
                    @group(0) @binding(1) var<storage> cellState: array<u32>;

                    @vertex
                    fn vertexMain(input: VertexIn) -> VertexOut {
                        let state = f32(cellState[input.instance]);
                        let i = f32(input.instance);
                        let cell = vec2f(i%grid.x,floor(i/grid.x));
                        let cellOffset = cell/grid * 2;
                        let apos = (input.pos*state + 1)/grid - 1 + cellOffset;
                        
                        var output: VertexOut;
                        output.pos = vec4f(apos,0,1);
                        output.cell = cell;

                        return output;
                    }

                    @fragment
                    fn fragmentMain(@location(0) cell: vec2f) -> @location(0) vec4f {
                        let c = cell/grid;
                        return vec4f(c,1 - c.x,1);
                    }
                `
            });

            const cellPipeline = device.createRenderPipeline({
                label: "Cell pipeline",
                layout: "auto",
                vertex: {
                    module: cellShaderModule,
                    entryPoint: "vertexMain",
                    buffers: [vertexBufferLayout]
                },
                fragment: {
                    module: cellShaderModule,
                    entryPoint: "fragmentMain",
                    targets: [{
                    format: canvasFormat
                    }]
                }
                });

            

            const cellStateArray = new Uint32Array(GRID_SIZE*GRID_SIZE);
            
            

            const cellStateStorage = [
                device.createBuffer({
                    label: "Cell state A",
                    size: cellStateArray.byteLength,
                    usage: GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,
                }),
                device.createBuffer({
                    label: "Cell state B",
                    size: cellStateArray.byteLength,
                    usage: GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,
                }),
            ]

            for (let i=0;i<cellStateArray.length;i+=3){
                    cellStateArray[i]=1;
            }
            device.queue.writeBuffer(cellStateStorage[0], 0, cellStateArray);
            
            for (let i=0;i<cellStateArray.length;i+=2){
                cellStateArray[i]=1;
            }
            device.queue.writeBuffer(cellStateStorage[1], 0, cellStateArray);


            const bindGroups = [
                device.createBindGroup({
                label: "Cell renderer bind group",
                    layout: cellPipeline.getBindGroupLayout(0),
                    entries: [{
                        binding: 0,
                        resource: {buffer: uniformBuffer}
                    },
                    {
                        binding: 1, 
                        resource: {buffer: cellStateStorage[0]}
                    }
                ],
                }),
                device.createBindGroup({
                label: "Cell renderer bind group",
                    layout: cellPipeline.getBindGroupLayout(0),
                    entries: [{
                        binding: 0,
                        resource: {buffer: uniformBuffer}
                    },
                    {
                        binding: 1, 
                        resource: {buffer: cellStateStorage[1]}
                    }
                ],
                })
            ];
            
            function render(){
                const encoder = device.createCommandEncoder();
                const pass = encoder.beginRenderPass({
                    colorAttachments: [{
                        view: context.getCurrentTexture().createView(),
                        loadOp: "clear",
                        clearValue: [0,0.1, 0.32, 1],
                        storeOp: "store",
                    }]
                });

                pass.setPipeline(cellPipeline);
                pass.setVertexBuffer(0, vertexBuffer);
                pass.setBindGroup(0, bindGroups[step%2]);
                pass.draw(vertices.length/2, GRID_SIZE*GRID_SIZE);

                pass.end();
                device.queue.submit([encoder.finish()]);
            }
            function udpateGrid(){
                step++;
                render();
            }

            setInterval(udpateGrid, UPDATE_INTERVAL);
        }


        

        

        main();
    </script>
</body>
</html>