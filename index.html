<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game of Life</title>
</head>
<body>
    <canvas id="canvas" width="512" height="512"></canvas>


    <script>
        async function main(){

            if (!navigator.gpu){
                alert("WebGPU not supported");
            }

            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter){
                alert("Adapter not found!");
            }

            const device = await adapter.requestDevice();

            const canvas = document.getElementById("canvas");
            const context = canvas.getContext("webgpu");
            const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device: device,
                format: canvasFormat,
            });


            const encoder = device.createCommandEncoder();
            const pass = encoder.beginRenderPass({
                colorAttachments: [{
                    view: context.getCurrentTexture().createView(),
                    loadOp: "clear",
                    clearValue: [0,0.1, 0.32, 1],
                    storeOp: "store",
                }]
            });


            const vertices = new Float32Array([
                -0.8, -0.8,
                 0.8, -0.8,
                 0.8,  0.8,

                 0.8,  0.8,
                -0.8,  0.8,
                -0.8, -0.8,
            ])

            const vertexBuffer = device.createBuffer({
                label: "Cell vertices",
                size: vertices.byteLength,
                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
                });

            device.queue.writeBuffer(vertexBuffer, 0, vertices);
            const vertexBufferLayout = {
                arrayStride: 8,
                attributes: [{
                    format: "float32x2",
                    offset: 0,
                    shaderLocation: 0,
                }],
            };

            const cellShaderModule = device.createShaderModule({
                label: "Cell shader",
                code:`
                    @vertex
                    fn vertexMain(@location(0) pos: vec2f) -> 
                    @builtin(position) vec4f{
                        return vec4f(pos,0,1);
                    }

                    @fragment
                    fn fragmentMain() -> @location(0) vec4f {
                        return vec4f(1,0,0,1);
                    }
                `
            });

            const cellPipeline = device.createRenderPipeline({
                label: "Cell pipeline",
                layout: "auto",
                vertex: {
                    module: cellShaderModule,
                    entryPoint: "vertexMain",
                    buffers: [vertexBufferLayout]
                },
                fragment: {
                    module: cellShaderModule,
                    entryPoint: "fragmentMain",
                    targets: [{
                    format: canvasFormat
                    }]
                }
                });
            pass.setPipeline(cellPipeline);
            pass.setVertexBuffer(0, vertexBuffer);
            pass.draw(vertices.length/2);


            
            pass.end();
            device.queue.submit([encoder.finish()]);
        }
        main();
    </script>
</body>
</html>